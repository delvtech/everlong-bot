"""A web3.py Contract class for the IPermissionedStrategy contract.

DO NOT EDIT.  This file was generated by pypechain v0.0.49.
See documentation at https://github.com/delvtech/pypechain """

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

# methods are overridden with specific arguments instead of generic *args, **kwargs
# pylint: disable=arguments-differ

# consumers have too many opinions on line length
# pylint: disable=line-too-long

# We use protected classes within pypechain
# pylint: disable=protected-access

# We sometimes define a variable that might not be returned in `call`,
# but we still may want to call the function
# pylint: disable=unused-variable


from __future__ import annotations

from typing import Any, Iterable, NamedTuple, Sequence, Type, cast, overload

from eth_account.signers.local import LocalAccount
from eth_typing import ABI, ChecksumAddress, HexStr
from hexbytes import HexBytes
from pypechain.core import (
    BaseEventArgs,
    PypechainBaseContractErrors,
    PypechainContractFunction,
    PypechainOverloadedFunctions,
    combomethod_typed,
    dataclass_to_tuple,
    expand_struct_type_str,
    get_arg_type_names,
    rename_returned_types,
)
from typing_extensions import Self
from web3 import Web3
from web3._utils.events import EventLogErrorFlags
from web3._utils.filters import LogFilter
from web3.contract.contract import Contract, ContractConstructor, ContractEvent, ContractEvents, ContractFunctions
from web3.logs import WARN
from web3.types import BlockIdentifier, StateOverride, TxParams, TxReceipt

from .IPermissionedStrategyTypes import (
    ApprovalEvent,
    DepositEvent,
    NewTokenizedStrategyEvent,
    ReportedEvent,
    StrategyShutdownEvent,
    TransferEvent,
    UpdateEmergencyAdminEvent,
    UpdateKeeperEvent,
    UpdateManagementEvent,
    UpdatePendingManagementEvent,
    UpdatePerformanceFeeEvent,
    UpdatePerformanceFeeRecipientEvent,
    UpdateProfitMaxUnlockTimeEvent,
    WithdrawEvent,
)

structs = {}

ipermissionedstrategy_abi: ABI = cast(
    ABI,
    [
        {
            "type": "function",
            "name": "DOMAIN_SEPARATOR",
            "inputs": [],
            "outputs": [{"name": "", "type": "bytes32", "internalType": "bytes32"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "FACTORY",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "MAX_FEE",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint16", "internalType": "uint16"}],
            "stateMutability": "view",
        },
        {"type": "function", "name": "acceptManagement", "inputs": [], "outputs": [], "stateMutability": "nonpayable"},
        {
            "type": "function",
            "name": "allowance",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "spender", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "apiVersion",
            "inputs": [],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "approve",
            "inputs": [
                {"name": "spender", "type": "address", "internalType": "address"},
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "asset",
            "inputs": [],
            "outputs": [{"name": "assetTokenAddress", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "availableDepositLimit",
            "inputs": [{"name": "_owner", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "availableWithdrawLimit",
            "inputs": [{"name": "_owner", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [{"name": "account", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "convertToAssets",
            "inputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "convertToShares",
            "inputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "decimals",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint8", "internalType": "uint8"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "deployFunds",
            "inputs": [{"name": "_assets", "type": "uint256", "internalType": "uint256"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "deposit",
            "inputs": [
                {"name": "assets", "type": "uint256", "internalType": "uint256"},
                {"name": "receiver", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "emergencyAdmin",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "emergencyWithdraw",
            "inputs": [{"name": "_amount", "type": "uint256", "internalType": "uint256"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "freeFunds",
            "inputs": [{"name": "_amount", "type": "uint256", "internalType": "uint256"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "fullProfitUnlockDate",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "harvestAndReport",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "initialize",
            "inputs": [
                {"name": "_asset", "type": "address", "internalType": "address"},
                {"name": "_name", "type": "string", "internalType": "string"},
                {"name": "_management", "type": "address", "internalType": "address"},
                {"name": "_performanceFeeRecipient", "type": "address", "internalType": "address"},
                {"name": "_keeper", "type": "address", "internalType": "address"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "isShutdown",
            "inputs": [],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "keeper",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "lastReport",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "management",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxDeposit",
            "inputs": [{"name": "receiver", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "maxAssets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxMint",
            "inputs": [{"name": "receiver", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "maxShares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxRedeem",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxRedeem",
            "inputs": [{"name": "owner", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "maxShares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxWithdraw",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "maxWithdraw",
            "inputs": [{"name": "owner", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "maxAssets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "mint",
            "inputs": [
                {"name": "shares", "type": "uint256", "internalType": "uint256"},
                {"name": "receiver", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "nonces",
            "inputs": [{"name": "owner", "type": "address", "internalType": "address"}],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "pendingManagement",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "performanceFee",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint16", "internalType": "uint16"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "performanceFeeRecipient",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "permit",
            "inputs": [
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "spender", "type": "address", "internalType": "address"},
                {"name": "value", "type": "uint256", "internalType": "uint256"},
                {"name": "deadline", "type": "uint256", "internalType": "uint256"},
                {"name": "v", "type": "uint8", "internalType": "uint8"},
                {"name": "r", "type": "bytes32", "internalType": "bytes32"},
                {"name": "s", "type": "bytes32", "internalType": "bytes32"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "previewDeposit",
            "inputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "previewMint",
            "inputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "previewRedeem",
            "inputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "previewWithdraw",
            "inputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "outputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "pricePerShare",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "profitMaxUnlockTime",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "profitUnlockingRate",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "redeem",
            "inputs": [
                {"name": "shares", "type": "uint256", "internalType": "uint256"},
                {"name": "receiver", "type": "address", "internalType": "address"},
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "maxLoss", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "redeem",
            "inputs": [
                {"name": "shares", "type": "uint256", "internalType": "uint256"},
                {"name": "receiver", "type": "address", "internalType": "address"},
                {"name": "owner", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "assets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "report",
            "inputs": [],
            "outputs": [
                {"name": "_profit", "type": "uint256", "internalType": "uint256"},
                {"name": "_loss", "type": "uint256", "internalType": "uint256"},
            ],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "requireEmergencyAuthorized",
            "inputs": [{"name": "_sender", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "requireKeeperOrManagement",
            "inputs": [{"name": "_sender", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "requireManagement",
            "inputs": [{"name": "_sender", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "setDepositor",
            "inputs": [
                {"name": "_depositor", "type": "address", "internalType": "address"},
                {"name": "_enabled", "type": "bool", "internalType": "bool"},
            ],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setEmergencyAdmin",
            "inputs": [{"name": "_emergencyAdmin", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setKeeper",
            "inputs": [{"name": "_keeper", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setName",
            "inputs": [{"name": "_newName", "type": "string", "internalType": "string"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPendingManagement",
            "inputs": [{"name": "", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPerformanceFee",
            "inputs": [{"name": "_performanceFee", "type": "uint16", "internalType": "uint16"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setPerformanceFeeRecipient",
            "inputs": [{"name": "_performanceFeeRecipient", "type": "address", "internalType": "address"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "setProfitMaxUnlockTime",
            "inputs": [{"name": "_profitMaxUnlockTime", "type": "uint256", "internalType": "uint256"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {"type": "function", "name": "shutdownStrategy", "inputs": [], "outputs": [], "stateMutability": "nonpayable"},
        {
            "type": "function",
            "name": "shutdownWithdraw",
            "inputs": [{"name": "_amount", "type": "uint256", "internalType": "uint256"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [],
            "outputs": [{"name": "", "type": "string", "internalType": "string"}],
            "stateMutability": "view",
        },
        {"type": "function", "name": "tend", "inputs": [], "outputs": [], "stateMutability": "nonpayable"},
        {
            "type": "function",
            "name": "tendThis",
            "inputs": [{"name": "_totalIdle", "type": "uint256", "internalType": "uint256"}],
            "outputs": [],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "tendTrigger",
            "inputs": [],
            "outputs": [
                {"name": "", "type": "bool", "internalType": "bool"},
                {"name": "", "type": "bytes", "internalType": "bytes"},
            ],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "tokenizedStrategyAddress",
            "inputs": [],
            "outputs": [{"name": "", "type": "address", "internalType": "address"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalAssets",
            "inputs": [],
            "outputs": [{"name": "totalManagedAssets", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "totalSupply",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "transfer",
            "inputs": [
                {"name": "to", "type": "address", "internalType": "address"},
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {"name": "from", "type": "address", "internalType": "address"},
                {"name": "to", "type": "address", "internalType": "address"},
                {"name": "value", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "bool", "internalType": "bool"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "unlockedShares",
            "inputs": [],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "view",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "assets", "type": "uint256", "internalType": "uint256"},
                {"name": "receiver", "type": "address", "internalType": "address"},
                {"name": "owner", "type": "address", "internalType": "address"},
                {"name": "maxLoss", "type": "uint256", "internalType": "uint256"},
            ],
            "outputs": [{"name": "", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [
                {"name": "assets", "type": "uint256", "internalType": "uint256"},
                {"name": "receiver", "type": "address", "internalType": "address"},
                {"name": "owner", "type": "address", "internalType": "address"},
            ],
            "outputs": [{"name": "shares", "type": "uint256", "internalType": "uint256"}],
            "stateMutability": "nonpayable",
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {"name": "owner", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "spender", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "value", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Deposit",
            "inputs": [
                {"name": "sender", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "owner", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "assets", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "shares", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "NewTokenizedStrategy",
            "inputs": [
                {"name": "strategy", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "asset", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "apiVersion", "type": "string", "indexed": False, "internalType": "string"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Reported",
            "inputs": [
                {"name": "profit", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "loss", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "protocolFees", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "performanceFees", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {"type": "event", "name": "StrategyShutdown", "inputs": [], "anonymous": False},
        {
            "type": "event",
            "name": "Transfer",
            "inputs": [
                {"name": "from", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "to", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "value", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdateEmergencyAdmin",
            "inputs": [{"name": "newEmergencyAdmin", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdateKeeper",
            "inputs": [{"name": "newKeeper", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdateManagement",
            "inputs": [{"name": "newManagement", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdatePendingManagement",
            "inputs": [{"name": "newPendingManagement", "type": "address", "indexed": True, "internalType": "address"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdatePerformanceFee",
            "inputs": [{"name": "newPerformanceFee", "type": "uint16", "indexed": False, "internalType": "uint16"}],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdatePerformanceFeeRecipient",
            "inputs": [
                {"name": "newPerformanceFeeRecipient", "type": "address", "indexed": True, "internalType": "address"}
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "UpdateProfitMaxUnlockTime",
            "inputs": [
                {"name": "newProfitMaxUnlockTime", "type": "uint256", "indexed": False, "internalType": "uint256"}
            ],
            "anonymous": False,
        },
        {
            "type": "event",
            "name": "Withdraw",
            "inputs": [
                {"name": "sender", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "receiver", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "owner", "type": "address", "indexed": True, "internalType": "address"},
                {"name": "assets", "type": "uint256", "indexed": False, "internalType": "uint256"},
                {"name": "shares", "type": "uint256", "indexed": False, "internalType": "uint256"},
            ],
            "anonymous": False,
        },
    ],
)


class IPermissionedStrategyContractErrors(PypechainBaseContractErrors):
    """ContractErrors for the IPermissionedStrategy contract."""

    def __init__(
        self,
    ) -> None:

        self._all = []


class IPermissionedStrategyDOMAIN_SEPARATORContractFunction0(PypechainContractFunction):
    """ContractFunction for the DOMAIN_SEPARATOR() method."""

    _function_name = "DOMAIN_SEPARATOR"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bytes:
        """returns bytes."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bytes

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(bytes, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyDOMAIN_SEPARATORContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the DOMAIN_SEPARATOR method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "DOMAIN_SEPARATOR"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyDOMAIN_SEPARATORContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyDOMAIN_SEPARATORContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyDOMAIN_SEPARATORContractFunction0._type_signature: IPermissionedStrategyDOMAIN_SEPARATORContractFunction0,
        }
        return out


class IPermissionedStrategyFACTORYContractFunction0(PypechainContractFunction):
    """ContractFunction for the FACTORY() method."""

    _function_name = "FACTORY"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyFACTORYContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the FACTORY method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "FACTORY"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyFACTORYContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyFACTORYContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyFACTORYContractFunction0._type_signature: IPermissionedStrategyFACTORYContractFunction0,
        }
        return out


class IPermissionedStrategyMAX_FEEContractFunction0(PypechainContractFunction):
    """ContractFunction for the MAX_FEE() method."""

    _function_name = "MAX_FEE"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMAX_FEEContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the MAX_FEE method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "MAX_FEE"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyMAX_FEEContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyMAX_FEEContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyMAX_FEEContractFunction0._type_signature: IPermissionedStrategyMAX_FEEContractFunction0,
        }
        return out


class IPermissionedStrategyAcceptManagementContractFunction0(PypechainContractFunction):
    """ContractFunction for the acceptManagement() method."""

    _function_name = "acceptManagement"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyAcceptManagementContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the acceptManagement method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "acceptManagement"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyAcceptManagementContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyAcceptManagementContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyAcceptManagementContractFunction0._type_signature: IPermissionedStrategyAcceptManagementContractFunction0,
        }
        return out


class IPermissionedStrategyAllowanceContractFunction0(PypechainContractFunction):
    """ContractFunction for the allowance(str,str) method."""

    _function_name = "allowance"
    _type_signature = expand_struct_type_str(tuple(["str", "str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyAllowanceContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the allowance method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "allowance"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, spender: str) -> IPermissionedStrategyAllowanceContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyAllowanceContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyAllowanceContractFunction0._type_signature: IPermissionedStrategyAllowanceContractFunction0,
        }
        return out


class IPermissionedStrategyApiVersionContractFunction0(PypechainContractFunction):
    """ContractFunction for the apiVersion() method."""

    _function_name = "apiVersion"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyApiVersionContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the apiVersion method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "apiVersion"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyApiVersionContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyApiVersionContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyApiVersionContractFunction0._type_signature: IPermissionedStrategyApiVersionContractFunction0,
        }
        return out


class IPermissionedStrategyApproveContractFunction0(PypechainContractFunction):
    """ContractFunction for the approve(str,int) method."""

    _function_name = "approve"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(bool, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyApproveContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the approve method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "approve"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, spender: str, value: int) -> IPermissionedStrategyApproveContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyApproveContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyApproveContractFunction0._type_signature: IPermissionedStrategyApproveContractFunction0,
        }
        return out


class IPermissionedStrategyAssetContractFunction0(PypechainContractFunction):
    """ContractFunction for the asset() method."""

    _function_name = "asset"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyAssetContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the asset method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "asset"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyAssetContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyAssetContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyAssetContractFunction0._type_signature: IPermissionedStrategyAssetContractFunction0,
        }
        return out


class IPermissionedStrategyAvailableDepositLimitContractFunction0(PypechainContractFunction):
    """ContractFunction for the availableDepositLimit(str) method."""

    _function_name = "availableDepositLimit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyAvailableDepositLimitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the availableDepositLimit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "availableDepositLimit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _owner: str) -> IPermissionedStrategyAvailableDepositLimitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyAvailableDepositLimitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyAvailableDepositLimitContractFunction0._type_signature: IPermissionedStrategyAvailableDepositLimitContractFunction0,
        }
        return out


class IPermissionedStrategyAvailableWithdrawLimitContractFunction0(PypechainContractFunction):
    """ContractFunction for the availableWithdrawLimit(str) method."""

    _function_name = "availableWithdrawLimit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyAvailableWithdrawLimitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the availableWithdrawLimit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "availableWithdrawLimit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _owner: str) -> IPermissionedStrategyAvailableWithdrawLimitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyAvailableWithdrawLimitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyAvailableWithdrawLimitContractFunction0._type_signature: IPermissionedStrategyAvailableWithdrawLimitContractFunction0,
        }
        return out


class IPermissionedStrategyBalanceOfContractFunction0(PypechainContractFunction):
    """ContractFunction for the balanceOf(str) method."""

    _function_name = "balanceOf"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyBalanceOfContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the balanceOf method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "balanceOf"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, account: str) -> IPermissionedStrategyBalanceOfContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyBalanceOfContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyBalanceOfContractFunction0._type_signature: IPermissionedStrategyBalanceOfContractFunction0,
        }
        return out


class IPermissionedStrategyConvertToAssetsContractFunction0(PypechainContractFunction):
    """ContractFunction for the convertToAssets(int) method."""

    _function_name = "convertToAssets"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyConvertToAssetsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the convertToAssets method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "convertToAssets"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, shares: int) -> IPermissionedStrategyConvertToAssetsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyConvertToAssetsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyConvertToAssetsContractFunction0._type_signature: IPermissionedStrategyConvertToAssetsContractFunction0,
        }
        return out


class IPermissionedStrategyConvertToSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the convertToShares(int) method."""

    _function_name = "convertToShares"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyConvertToSharesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the convertToShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "convertToShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: int) -> IPermissionedStrategyConvertToSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyConvertToSharesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyConvertToSharesContractFunction0._type_signature: IPermissionedStrategyConvertToSharesContractFunction0,
        }
        return out


class IPermissionedStrategyDecimalsContractFunction0(PypechainContractFunction):
    """ContractFunction for the decimals() method."""

    _function_name = "decimals"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyDecimalsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the decimals method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "decimals"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyDecimalsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyDecimalsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyDecimalsContractFunction0._type_signature: IPermissionedStrategyDecimalsContractFunction0,
        }
        return out


class IPermissionedStrategyDeployFundsContractFunction0(PypechainContractFunction):
    """ContractFunction for the deployFunds(int) method."""

    _function_name = "deployFunds"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyDeployFundsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deployFunds method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deployFunds"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _assets: int) -> IPermissionedStrategyDeployFundsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyDeployFundsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyDeployFundsContractFunction0._type_signature: IPermissionedStrategyDeployFundsContractFunction0,
        }
        return out


class IPermissionedStrategyDepositContractFunction0(PypechainContractFunction):
    """ContractFunction for the deposit(int,str) method."""

    _function_name = "deposit"
    _type_signature = expand_struct_type_str(tuple(["int", "str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyDepositContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the deposit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "deposit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: int, receiver: str) -> IPermissionedStrategyDepositContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyDepositContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyDepositContractFunction0._type_signature: IPermissionedStrategyDepositContractFunction0,
        }
        return out


class IPermissionedStrategyEmergencyAdminContractFunction0(PypechainContractFunction):
    """ContractFunction for the emergencyAdmin() method."""

    _function_name = "emergencyAdmin"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyEmergencyAdminContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the emergencyAdmin method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "emergencyAdmin"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyEmergencyAdminContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyEmergencyAdminContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyEmergencyAdminContractFunction0._type_signature: IPermissionedStrategyEmergencyAdminContractFunction0,
        }
        return out


class IPermissionedStrategyEmergencyWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the emergencyWithdraw(int) method."""

    _function_name = "emergencyWithdraw"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyEmergencyWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the emergencyWithdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "emergencyWithdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _amount: int) -> IPermissionedStrategyEmergencyWithdrawContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyEmergencyWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyEmergencyWithdrawContractFunction0._type_signature: IPermissionedStrategyEmergencyWithdrawContractFunction0,
        }
        return out


class IPermissionedStrategyFreeFundsContractFunction0(PypechainContractFunction):
    """ContractFunction for the freeFunds(int) method."""

    _function_name = "freeFunds"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyFreeFundsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the freeFunds method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "freeFunds"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _amount: int) -> IPermissionedStrategyFreeFundsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyFreeFundsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyFreeFundsContractFunction0._type_signature: IPermissionedStrategyFreeFundsContractFunction0,
        }
        return out


class IPermissionedStrategyFullProfitUnlockDateContractFunction0(PypechainContractFunction):
    """ContractFunction for the fullProfitUnlockDate() method."""

    _function_name = "fullProfitUnlockDate"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyFullProfitUnlockDateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the fullProfitUnlockDate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "fullProfitUnlockDate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyFullProfitUnlockDateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyFullProfitUnlockDateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyFullProfitUnlockDateContractFunction0._type_signature: IPermissionedStrategyFullProfitUnlockDateContractFunction0,
        }
        return out


class IPermissionedStrategyHarvestAndReportContractFunction0(PypechainContractFunction):
    """ContractFunction for the harvestAndReport() method."""

    _function_name = "harvestAndReport"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyHarvestAndReportContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the harvestAndReport method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "harvestAndReport"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyHarvestAndReportContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyHarvestAndReportContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyHarvestAndReportContractFunction0._type_signature: IPermissionedStrategyHarvestAndReportContractFunction0,
        }
        return out


class IPermissionedStrategyInitializeContractFunction0(PypechainContractFunction):
    """ContractFunction for the initialize(str,str,str,str,str) method."""

    _function_name = "initialize"
    _type_signature = expand_struct_type_str(tuple(["str", "str", "str", "str", "str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyInitializeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the initialize method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "initialize"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _asset: str, _name: str, _management: str, _performanceFeeRecipient: str, _keeper: str) -> IPermissionedStrategyInitializeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyInitializeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyInitializeContractFunction0._type_signature: IPermissionedStrategyInitializeContractFunction0,
        }
        return out


class IPermissionedStrategyIsShutdownContractFunction0(PypechainContractFunction):
    """ContractFunction for the isShutdown() method."""

    _function_name = "isShutdown"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(bool, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyIsShutdownContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the isShutdown method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "isShutdown"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyIsShutdownContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyIsShutdownContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyIsShutdownContractFunction0._type_signature: IPermissionedStrategyIsShutdownContractFunction0,
        }
        return out


class IPermissionedStrategyKeeperContractFunction0(PypechainContractFunction):
    """ContractFunction for the keeper() method."""

    _function_name = "keeper"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyKeeperContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the keeper method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "keeper"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyKeeperContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyKeeperContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyKeeperContractFunction0._type_signature: IPermissionedStrategyKeeperContractFunction0,
        }
        return out


class IPermissionedStrategyLastReportContractFunction0(PypechainContractFunction):
    """ContractFunction for the lastReport() method."""

    _function_name = "lastReport"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyLastReportContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the lastReport method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "lastReport"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyLastReportContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyLastReportContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyLastReportContractFunction0._type_signature: IPermissionedStrategyLastReportContractFunction0,
        }
        return out


class IPermissionedStrategyManagementContractFunction0(PypechainContractFunction):
    """ContractFunction for the management() method."""

    _function_name = "management"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyManagementContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the management method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "management"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyManagementContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyManagementContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyManagementContractFunction0._type_signature: IPermissionedStrategyManagementContractFunction0,
        }
        return out


class IPermissionedStrategyMaxDepositContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxDeposit(str) method."""

    _function_name = "maxDeposit"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMaxDepositContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the maxDeposit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxDeposit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiver: str) -> IPermissionedStrategyMaxDepositContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyMaxDepositContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyMaxDepositContractFunction0._type_signature: IPermissionedStrategyMaxDepositContractFunction0,
        }
        return out


class IPermissionedStrategyMaxMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxMint(str) method."""

    _function_name = "maxMint"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMaxMintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the maxMint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxMint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, receiver: str) -> IPermissionedStrategyMaxMintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyMaxMintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyMaxMintContractFunction0._type_signature: IPermissionedStrategyMaxMintContractFunction0,
        }
        return out


class IPermissionedStrategyMaxRedeemContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxRedeem(str,int) method."""

    _function_name = "maxRedeem"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMaxRedeemContractFunction1(PypechainContractFunction):
    """ContractFunction for the maxRedeem(str) method."""

    _function_name = "maxRedeem"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMaxRedeemContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the maxRedeem method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxRedeem"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, arg2: int) -> IPermissionedStrategyMaxRedeemContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, owner: str) -> IPermissionedStrategyMaxRedeemContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyMaxRedeemContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyMaxRedeemContractFunction0._type_signature: IPermissionedStrategyMaxRedeemContractFunction0,
            IPermissionedStrategyMaxRedeemContractFunction1._type_signature: IPermissionedStrategyMaxRedeemContractFunction1,
        }
        return out


class IPermissionedStrategyMaxWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the maxWithdraw(str,int) method."""

    _function_name = "maxWithdraw"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMaxWithdrawContractFunction1(PypechainContractFunction):
    """ContractFunction for the maxWithdraw(str) method."""

    _function_name = "maxWithdraw"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMaxWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the maxWithdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "maxWithdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, arg2: int) -> IPermissionedStrategyMaxWithdrawContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, owner: str) -> IPermissionedStrategyMaxWithdrawContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyMaxWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyMaxWithdrawContractFunction0._type_signature: IPermissionedStrategyMaxWithdrawContractFunction0,
            IPermissionedStrategyMaxWithdrawContractFunction1._type_signature: IPermissionedStrategyMaxWithdrawContractFunction1,
        }
        return out


class IPermissionedStrategyMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the mint(int,str) method."""

    _function_name = "mint"
    _type_signature = expand_struct_type_str(tuple(["int", "str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyMintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the mint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "mint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, shares: int, receiver: str) -> IPermissionedStrategyMintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyMintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyMintContractFunction0._type_signature: IPermissionedStrategyMintContractFunction0,
        }
        return out


class IPermissionedStrategyNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the name() method."""

    _function_name = "name"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyNameContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the name method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "name"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyNameContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyNameContractFunction0._type_signature: IPermissionedStrategyNameContractFunction0,
        }
        return out


class IPermissionedStrategyNoncesContractFunction0(PypechainContractFunction):
    """ContractFunction for the nonces(str) method."""

    _function_name = "nonces"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyNoncesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the nonces method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "nonces"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str) -> IPermissionedStrategyNoncesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyNoncesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyNoncesContractFunction0._type_signature: IPermissionedStrategyNoncesContractFunction0,
        }
        return out


class IPermissionedStrategyPendingManagementContractFunction0(PypechainContractFunction):
    """ContractFunction for the pendingManagement() method."""

    _function_name = "pendingManagement"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPendingManagementContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the pendingManagement method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "pendingManagement"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyPendingManagementContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPendingManagementContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPendingManagementContractFunction0._type_signature: IPermissionedStrategyPendingManagementContractFunction0,
        }
        return out


class IPermissionedStrategyPerformanceFeeContractFunction0(PypechainContractFunction):
    """ContractFunction for the performanceFee() method."""

    _function_name = "performanceFee"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPerformanceFeeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the performanceFee method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "performanceFee"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyPerformanceFeeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPerformanceFeeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPerformanceFeeContractFunction0._type_signature: IPermissionedStrategyPerformanceFeeContractFunction0,
        }
        return out


class IPermissionedStrategyPerformanceFeeRecipientContractFunction0(PypechainContractFunction):
    """ContractFunction for the performanceFeeRecipient() method."""

    _function_name = "performanceFeeRecipient"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPerformanceFeeRecipientContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the performanceFeeRecipient method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "performanceFeeRecipient"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyPerformanceFeeRecipientContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPerformanceFeeRecipientContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPerformanceFeeRecipientContractFunction0._type_signature: IPermissionedStrategyPerformanceFeeRecipientContractFunction0,
        }
        return out


class IPermissionedStrategyPermitContractFunction0(PypechainContractFunction):
    """ContractFunction for the permit(str,str,int,int,int,bytes,bytes) method."""

    _function_name = "permit"
    _type_signature = expand_struct_type_str(tuple(["str", "str", "int", "int", "int", "bytes", "bytes"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyPermitContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the permit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "permit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, owner: str, spender: str, value: int, deadline: int, v: int, r: bytes, s: bytes) -> IPermissionedStrategyPermitContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPermitContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPermitContractFunction0._type_signature: IPermissionedStrategyPermitContractFunction0,
        }
        return out


class IPermissionedStrategyPreviewDepositContractFunction0(PypechainContractFunction):
    """ContractFunction for the previewDeposit(int) method."""

    _function_name = "previewDeposit"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPreviewDepositContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the previewDeposit method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "previewDeposit"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: int) -> IPermissionedStrategyPreviewDepositContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPreviewDepositContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPreviewDepositContractFunction0._type_signature: IPermissionedStrategyPreviewDepositContractFunction0,
        }
        return out


class IPermissionedStrategyPreviewMintContractFunction0(PypechainContractFunction):
    """ContractFunction for the previewMint(int) method."""

    _function_name = "previewMint"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPreviewMintContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the previewMint method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "previewMint"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, shares: int) -> IPermissionedStrategyPreviewMintContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPreviewMintContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPreviewMintContractFunction0._type_signature: IPermissionedStrategyPreviewMintContractFunction0,
        }
        return out


class IPermissionedStrategyPreviewRedeemContractFunction0(PypechainContractFunction):
    """ContractFunction for the previewRedeem(int) method."""

    _function_name = "previewRedeem"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPreviewRedeemContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the previewRedeem method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "previewRedeem"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, shares: int) -> IPermissionedStrategyPreviewRedeemContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPreviewRedeemContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPreviewRedeemContractFunction0._type_signature: IPermissionedStrategyPreviewRedeemContractFunction0,
        }
        return out


class IPermissionedStrategyPreviewWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the previewWithdraw(int) method."""

    _function_name = "previewWithdraw"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPreviewWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the previewWithdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "previewWithdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: int) -> IPermissionedStrategyPreviewWithdrawContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPreviewWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPreviewWithdrawContractFunction0._type_signature: IPermissionedStrategyPreviewWithdrawContractFunction0,
        }
        return out


class IPermissionedStrategyPricePerShareContractFunction0(PypechainContractFunction):
    """ContractFunction for the pricePerShare() method."""

    _function_name = "pricePerShare"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyPricePerShareContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the pricePerShare method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "pricePerShare"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyPricePerShareContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyPricePerShareContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyPricePerShareContractFunction0._type_signature: IPermissionedStrategyPricePerShareContractFunction0,
        }
        return out


class IPermissionedStrategyProfitMaxUnlockTimeContractFunction0(PypechainContractFunction):
    """ContractFunction for the profitMaxUnlockTime() method."""

    _function_name = "profitMaxUnlockTime"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyProfitMaxUnlockTimeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the profitMaxUnlockTime method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "profitMaxUnlockTime"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyProfitMaxUnlockTimeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyProfitMaxUnlockTimeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyProfitMaxUnlockTimeContractFunction0._type_signature: IPermissionedStrategyProfitMaxUnlockTimeContractFunction0,
        }
        return out


class IPermissionedStrategyProfitUnlockingRateContractFunction0(PypechainContractFunction):
    """ContractFunction for the profitUnlockingRate() method."""

    _function_name = "profitUnlockingRate"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyProfitUnlockingRateContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the profitUnlockingRate method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "profitUnlockingRate"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyProfitUnlockingRateContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyProfitUnlockingRateContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyProfitUnlockingRateContractFunction0._type_signature: IPermissionedStrategyProfitUnlockingRateContractFunction0,
        }
        return out


class IPermissionedStrategyRedeemContractFunction0(PypechainContractFunction):
    """ContractFunction for the redeem(int,str,str,int) method."""

    _function_name = "redeem"
    _type_signature = expand_struct_type_str(tuple(["int", "str", "str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyRedeemContractFunction1(PypechainContractFunction):
    """ContractFunction for the redeem(int,str,str) method."""

    _function_name = "redeem"
    _type_signature = expand_struct_type_str(tuple(["int", "str", "str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyRedeemContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the redeem method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "redeem"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, shares: int, receiver: str, owner: str, maxLoss: int) -> IPermissionedStrategyRedeemContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, shares: int, receiver: str, owner: str) -> IPermissionedStrategyRedeemContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyRedeemContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyRedeemContractFunction0._type_signature: IPermissionedStrategyRedeemContractFunction0,
            IPermissionedStrategyRedeemContractFunction1._type_signature: IPermissionedStrategyRedeemContractFunction1,
        }
        return out


class IPermissionedStrategyReportContractFunction0(PypechainContractFunction):
    """ContractFunction for the report() method."""

    _function_name = "report"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for Report."""

        profit: int
        loss: int

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [int, int]

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return self.ReturnValues(*rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyReportContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the report method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "report"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyReportContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyReportContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyReportContractFunction0._type_signature: IPermissionedStrategyReportContractFunction0,
        }
        return out


class IPermissionedStrategyRequireEmergencyAuthorizedContractFunction0(PypechainContractFunction):
    """ContractFunction for the requireEmergencyAuthorized(str) method."""

    _function_name = "requireEmergencyAuthorized"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyRequireEmergencyAuthorizedContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the requireEmergencyAuthorized method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "requireEmergencyAuthorized"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str) -> IPermissionedStrategyRequireEmergencyAuthorizedContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyRequireEmergencyAuthorizedContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyRequireEmergencyAuthorizedContractFunction0._type_signature: IPermissionedStrategyRequireEmergencyAuthorizedContractFunction0,
        }
        return out


class IPermissionedStrategyRequireKeeperOrManagementContractFunction0(PypechainContractFunction):
    """ContractFunction for the requireKeeperOrManagement(str) method."""

    _function_name = "requireKeeperOrManagement"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyRequireKeeperOrManagementContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the requireKeeperOrManagement method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "requireKeeperOrManagement"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str) -> IPermissionedStrategyRequireKeeperOrManagementContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyRequireKeeperOrManagementContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyRequireKeeperOrManagementContractFunction0._type_signature: IPermissionedStrategyRequireKeeperOrManagementContractFunction0,
        }
        return out


class IPermissionedStrategyRequireManagementContractFunction0(PypechainContractFunction):
    """ContractFunction for the requireManagement(str) method."""

    _function_name = "requireManagement"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyRequireManagementContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the requireManagement method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "requireManagement"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _sender: str) -> IPermissionedStrategyRequireManagementContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyRequireManagementContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyRequireManagementContractFunction0._type_signature: IPermissionedStrategyRequireManagementContractFunction0,
        }
        return out


class IPermissionedStrategySetDepositorContractFunction0(PypechainContractFunction):
    """ContractFunction for the setDepositor(str,bool) method."""

    _function_name = "setDepositor"
    _type_signature = expand_struct_type_str(tuple(["str", "bool"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetDepositorContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setDepositor method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setDepositor"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _depositor: str, _enabled: bool) -> IPermissionedStrategySetDepositorContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetDepositorContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetDepositorContractFunction0._type_signature: IPermissionedStrategySetDepositorContractFunction0,
        }
        return out


class IPermissionedStrategySetEmergencyAdminContractFunction0(PypechainContractFunction):
    """ContractFunction for the setEmergencyAdmin(str) method."""

    _function_name = "setEmergencyAdmin"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetEmergencyAdminContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setEmergencyAdmin method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setEmergencyAdmin"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _emergencyAdmin: str) -> IPermissionedStrategySetEmergencyAdminContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetEmergencyAdminContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetEmergencyAdminContractFunction0._type_signature: IPermissionedStrategySetEmergencyAdminContractFunction0,
        }
        return out


class IPermissionedStrategySetKeeperContractFunction0(PypechainContractFunction):
    """ContractFunction for the setKeeper(str) method."""

    _function_name = "setKeeper"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetKeeperContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setKeeper method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setKeeper"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _keeper: str) -> IPermissionedStrategySetKeeperContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetKeeperContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetKeeperContractFunction0._type_signature: IPermissionedStrategySetKeeperContractFunction0,
        }
        return out


class IPermissionedStrategySetNameContractFunction0(PypechainContractFunction):
    """ContractFunction for the setName(str) method."""

    _function_name = "setName"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetNameContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setName method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setName"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _newName: str) -> IPermissionedStrategySetNameContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetNameContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetNameContractFunction0._type_signature: IPermissionedStrategySetNameContractFunction0,
        }
        return out


class IPermissionedStrategySetPendingManagementContractFunction0(PypechainContractFunction):
    """ContractFunction for the setPendingManagement(str) method."""

    _function_name = "setPendingManagement"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetPendingManagementContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setPendingManagement method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPendingManagement"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, arg1: str) -> IPermissionedStrategySetPendingManagementContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetPendingManagementContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetPendingManagementContractFunction0._type_signature: IPermissionedStrategySetPendingManagementContractFunction0,
        }
        return out


class IPermissionedStrategySetPerformanceFeeContractFunction0(PypechainContractFunction):
    """ContractFunction for the setPerformanceFee(int) method."""

    _function_name = "setPerformanceFee"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetPerformanceFeeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setPerformanceFee method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPerformanceFee"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _performanceFee: int) -> IPermissionedStrategySetPerformanceFeeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetPerformanceFeeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetPerformanceFeeContractFunction0._type_signature: IPermissionedStrategySetPerformanceFeeContractFunction0,
        }
        return out


class IPermissionedStrategySetPerformanceFeeRecipientContractFunction0(PypechainContractFunction):
    """ContractFunction for the setPerformanceFeeRecipient(str) method."""

    _function_name = "setPerformanceFeeRecipient"
    _type_signature = expand_struct_type_str(tuple(["str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetPerformanceFeeRecipientContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setPerformanceFeeRecipient method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setPerformanceFeeRecipient"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _performanceFeeRecipient: str) -> IPermissionedStrategySetPerformanceFeeRecipientContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetPerformanceFeeRecipientContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetPerformanceFeeRecipientContractFunction0._type_signature: IPermissionedStrategySetPerformanceFeeRecipientContractFunction0,
        }
        return out


class IPermissionedStrategySetProfitMaxUnlockTimeContractFunction0(PypechainContractFunction):
    """ContractFunction for the setProfitMaxUnlockTime(int) method."""

    _function_name = "setProfitMaxUnlockTime"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategySetProfitMaxUnlockTimeContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the setProfitMaxUnlockTime method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "setProfitMaxUnlockTime"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _profitMaxUnlockTime: int) -> IPermissionedStrategySetProfitMaxUnlockTimeContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySetProfitMaxUnlockTimeContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySetProfitMaxUnlockTimeContractFunction0._type_signature: IPermissionedStrategySetProfitMaxUnlockTimeContractFunction0,
        }
        return out


class IPermissionedStrategyShutdownStrategyContractFunction0(PypechainContractFunction):
    """ContractFunction for the shutdownStrategy() method."""

    _function_name = "shutdownStrategy"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyShutdownStrategyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the shutdownStrategy method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "shutdownStrategy"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyShutdownStrategyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyShutdownStrategyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyShutdownStrategyContractFunction0._type_signature: IPermissionedStrategyShutdownStrategyContractFunction0,
        }
        return out


class IPermissionedStrategyShutdownWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the shutdownWithdraw(int) method."""

    _function_name = "shutdownWithdraw"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyShutdownWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the shutdownWithdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "shutdownWithdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _amount: int) -> IPermissionedStrategyShutdownWithdrawContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyShutdownWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyShutdownWithdrawContractFunction0._type_signature: IPermissionedStrategyShutdownWithdrawContractFunction0,
        }
        return out


class IPermissionedStrategySymbolContractFunction0(PypechainContractFunction):
    """ContractFunction for the symbol() method."""

    _function_name = "symbol"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategySymbolContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the symbol method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "symbol"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategySymbolContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategySymbolContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategySymbolContractFunction0._type_signature: IPermissionedStrategySymbolContractFunction0,
        }
        return out


class IPermissionedStrategyTendContractFunction0(PypechainContractFunction):
    """ContractFunction for the tend() method."""

    _function_name = "tend"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyTendContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the tend method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "tend"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyTendContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTendContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTendContractFunction0._type_signature: IPermissionedStrategyTendContractFunction0,
        }
        return out


class IPermissionedStrategyTendThisContractFunction0(PypechainContractFunction):
    """ContractFunction for the tendThis(int) method."""

    _function_name = "tendThis"
    _type_signature = expand_struct_type_str(tuple(["int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> None:
        """returns None."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)


class IPermissionedStrategyTendThisContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the tendThis method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "tendThis"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _totalIdle: int) -> IPermissionedStrategyTendThisContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTendThisContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTendThisContractFunction0._type_signature: IPermissionedStrategyTendThisContractFunction0,
        }
        return out


class IPermissionedStrategyTendTriggerContractFunction0(PypechainContractFunction):
    """ContractFunction for the tendTrigger() method."""

    _function_name = "tendTrigger"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    class ReturnValues(NamedTuple):
        """The return named tuple for TendTrigger."""

        arg1: bool
        arg2: bytes

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> ReturnValues:
        """returns ReturnValues."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = [bool, bytes]

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return self.ReturnValues(*rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyTendTriggerContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the tendTrigger method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "tendTrigger"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyTendTriggerContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTendTriggerContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTendTriggerContractFunction0._type_signature: IPermissionedStrategyTendTriggerContractFunction0,
        }
        return out


class IPermissionedStrategyTokenizedStrategyAddressContractFunction0(PypechainContractFunction):
    """ContractFunction for the tokenizedStrategyAddress() method."""

    _function_name = "tokenizedStrategyAddress"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> str:
        """returns str."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = str

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(str, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyTokenizedStrategyAddressContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the tokenizedStrategyAddress method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "tokenizedStrategyAddress"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyTokenizedStrategyAddressContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTokenizedStrategyAddressContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTokenizedStrategyAddressContractFunction0._type_signature: IPermissionedStrategyTokenizedStrategyAddressContractFunction0,
        }
        return out


class IPermissionedStrategyTotalAssetsContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalAssets() method."""

    _function_name = "totalAssets"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyTotalAssetsContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the totalAssets method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalAssets"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyTotalAssetsContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTotalAssetsContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTotalAssetsContractFunction0._type_signature: IPermissionedStrategyTotalAssetsContractFunction0,
        }
        return out


class IPermissionedStrategyTotalSupplyContractFunction0(PypechainContractFunction):
    """ContractFunction for the totalSupply() method."""

    _function_name = "totalSupply"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyTotalSupplyContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the totalSupply method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "totalSupply"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyTotalSupplyContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTotalSupplyContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTotalSupplyContractFunction0._type_signature: IPermissionedStrategyTotalSupplyContractFunction0,
        }
        return out


class IPermissionedStrategyTransferContractFunction0(PypechainContractFunction):
    """ContractFunction for the transfer(str,int) method."""

    _function_name = "transfer"
    _type_signature = expand_struct_type_str(tuple(["str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(bool, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyTransferContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transfer method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transfer"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, to: str, value: int) -> IPermissionedStrategyTransferContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTransferContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTransferContractFunction0._type_signature: IPermissionedStrategyTransferContractFunction0,
        }
        return out


class IPermissionedStrategyTransferFromContractFunction0(PypechainContractFunction):
    """ContractFunction for the transferFrom(str,str,int) method."""

    _function_name = "transferFrom"
    _type_signature = expand_struct_type_str(tuple(["str", "str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> bool:
        """returns bool."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = bool

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(bool, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyTransferFromContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the transferFrom method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "transferFrom"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, _from: str, to: str, value: int) -> IPermissionedStrategyTransferFromContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyTransferFromContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyTransferFromContractFunction0._type_signature: IPermissionedStrategyTransferFromContractFunction0,
        }
        return out


class IPermissionedStrategyUnlockedSharesContractFunction0(PypechainContractFunction):
    """ContractFunction for the unlockedShares() method."""

    _function_name = "unlockedShares"
    _type_signature = expand_struct_type_str(tuple([]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyUnlockedSharesContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the unlockedShares method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "unlockedShares"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self) -> IPermissionedStrategyUnlockedSharesContractFunction0:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyUnlockedSharesContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyUnlockedSharesContractFunction0._type_signature: IPermissionedStrategyUnlockedSharesContractFunction0,
        }
        return out


class IPermissionedStrategyWithdrawContractFunction0(PypechainContractFunction):
    """ContractFunction for the withdraw(int,str,str,int) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(tuple(["int", "str", "str", "int"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyWithdrawContractFunction1(PypechainContractFunction):
    """ContractFunction for the withdraw(int,str,str) method."""

    _function_name = "withdraw"
    _type_signature = expand_struct_type_str(tuple(["int", "str", "str"]), structs)
    _error_class = IPermissionedStrategyContractErrors

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier | None = None,
        state_override: StateOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int."""
        # We handle the block identifier = None case here for typing.
        if block_identifier is None:
            block_identifier = self.w3.eth.default_block

        # Define the expected return types from the smart contract call
        return_types = int

        # Call the function
        raw_values = self._call(transaction, block_identifier, state_override, ccip_read_enabled)

        return cast(int, rename_returned_types(structs, return_types, raw_values))


class IPermissionedStrategyWithdrawContractFunction(PypechainOverloadedFunctions):
    """ContractFunction for the withdraw method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ# disable this warning when there is overloading
    # pylint: disable=function-redefined

    _function_name = "withdraw"

    # Make lookup for function signature -> overloaded function
    # The function signatures are python types, as we need to do a
    # lookup of arguments passed in to contract function
    _functions: dict[str, PypechainContractFunction]

    @overload
    def __call__(self, assets: int, receiver: str, owner: str, maxLoss: int) -> IPermissionedStrategyWithdrawContractFunction0:  # type: ignore
        ...

    @overload
    def __call__(self, assets: int, receiver: str, owner: str) -> IPermissionedStrategyWithdrawContractFunction1:  # type: ignore
        ...

    def __call__(self, *args, **kwargs) -> IPermissionedStrategyWithdrawContractFunction:  # type: ignore
        # Special case when there are no args or kwargs
        if len(args) == 0 and len(kwargs) == 0:
            # We need to specify the element identifier as the function call without arguments.
            # Despite this setting the member variable `abi_element_identifier`
            # that's shared across this object, this field gets overwritten in the
            # clone if arguments are provided.
            self.abi_element_identifier = self._function_name + "()"
            clone = super().__call__()
        else:
            clone = super().__call__(
                *(dataclass_to_tuple(arg) for arg in args),
                **{key: dataclass_to_tuple(arg) for key, arg in kwargs.items()},
            )

        # Arguments is the flattened set of arguments from args and kwargs, ordered by the abi
        # We get the python types of the args passed in, but remapped from tuples -> dataclasses
        arg_types = get_arg_type_names(clone.arguments)

        # Grab the relevant kwargs when factory was called.
        factory_kwargs = self._factory_kwargs
        factory_kwargs["abi_element_identifier"] = clone.abi_element_identifier

        function_obj = self._overloaded_functions[arg_types].factory(self._function_name, **factory_kwargs)

        function_obj.args = clone.args
        function_obj.kwargs = clone.kwargs

        # The `@overload` of `__call__` takes care of setting the type of this object correctly
        return function_obj  # type: ignore

    @classmethod
    def factory(cls, class_name: str, **kwargs: Any) -> Self:
        out = super().factory(class_name, **kwargs)
        # Store the factory args for downstream consumption
        out._factory_kwargs = kwargs

        # We initialize our overridden functions here.
        # Note that we use the initialized object to ensure each function
        # is attached to the instantiated object
        # (attached to a specific web3 and contract address)
        out._overloaded_functions = {
            IPermissionedStrategyWithdrawContractFunction0._type_signature: IPermissionedStrategyWithdrawContractFunction0,
            IPermissionedStrategyWithdrawContractFunction1._type_signature: IPermissionedStrategyWithdrawContractFunction1,
        }
        return out


class IPermissionedStrategyContractFunctions(ContractFunctions):
    """ContractFunctions for the IPermissionedStrategy contract."""

    DOMAIN_SEPARATOR: IPermissionedStrategyDOMAIN_SEPARATORContractFunction

    FACTORY: IPermissionedStrategyFACTORYContractFunction

    MAX_FEE: IPermissionedStrategyMAX_FEEContractFunction

    acceptManagement: IPermissionedStrategyAcceptManagementContractFunction

    allowance: IPermissionedStrategyAllowanceContractFunction

    apiVersion: IPermissionedStrategyApiVersionContractFunction

    approve: IPermissionedStrategyApproveContractFunction

    asset: IPermissionedStrategyAssetContractFunction

    availableDepositLimit: IPermissionedStrategyAvailableDepositLimitContractFunction

    availableWithdrawLimit: IPermissionedStrategyAvailableWithdrawLimitContractFunction

    balanceOf: IPermissionedStrategyBalanceOfContractFunction

    convertToAssets: IPermissionedStrategyConvertToAssetsContractFunction

    convertToShares: IPermissionedStrategyConvertToSharesContractFunction

    decimals: IPermissionedStrategyDecimalsContractFunction

    deployFunds: IPermissionedStrategyDeployFundsContractFunction

    deposit: IPermissionedStrategyDepositContractFunction

    emergencyAdmin: IPermissionedStrategyEmergencyAdminContractFunction

    emergencyWithdraw: IPermissionedStrategyEmergencyWithdrawContractFunction

    freeFunds: IPermissionedStrategyFreeFundsContractFunction

    fullProfitUnlockDate: IPermissionedStrategyFullProfitUnlockDateContractFunction

    harvestAndReport: IPermissionedStrategyHarvestAndReportContractFunction

    initialize: IPermissionedStrategyInitializeContractFunction

    isShutdown: IPermissionedStrategyIsShutdownContractFunction

    keeper: IPermissionedStrategyKeeperContractFunction

    lastReport: IPermissionedStrategyLastReportContractFunction

    management: IPermissionedStrategyManagementContractFunction

    maxDeposit: IPermissionedStrategyMaxDepositContractFunction

    maxMint: IPermissionedStrategyMaxMintContractFunction

    maxRedeem: IPermissionedStrategyMaxRedeemContractFunction

    maxWithdraw: IPermissionedStrategyMaxWithdrawContractFunction

    mint: IPermissionedStrategyMintContractFunction

    name: IPermissionedStrategyNameContractFunction

    nonces: IPermissionedStrategyNoncesContractFunction

    pendingManagement: IPermissionedStrategyPendingManagementContractFunction

    performanceFee: IPermissionedStrategyPerformanceFeeContractFunction

    performanceFeeRecipient: IPermissionedStrategyPerformanceFeeRecipientContractFunction

    permit: IPermissionedStrategyPermitContractFunction

    previewDeposit: IPermissionedStrategyPreviewDepositContractFunction

    previewMint: IPermissionedStrategyPreviewMintContractFunction

    previewRedeem: IPermissionedStrategyPreviewRedeemContractFunction

    previewWithdraw: IPermissionedStrategyPreviewWithdrawContractFunction

    pricePerShare: IPermissionedStrategyPricePerShareContractFunction

    profitMaxUnlockTime: IPermissionedStrategyProfitMaxUnlockTimeContractFunction

    profitUnlockingRate: IPermissionedStrategyProfitUnlockingRateContractFunction

    redeem: IPermissionedStrategyRedeemContractFunction

    report: IPermissionedStrategyReportContractFunction

    requireEmergencyAuthorized: IPermissionedStrategyRequireEmergencyAuthorizedContractFunction

    requireKeeperOrManagement: IPermissionedStrategyRequireKeeperOrManagementContractFunction

    requireManagement: IPermissionedStrategyRequireManagementContractFunction

    setDepositor: IPermissionedStrategySetDepositorContractFunction

    setEmergencyAdmin: IPermissionedStrategySetEmergencyAdminContractFunction

    setKeeper: IPermissionedStrategySetKeeperContractFunction

    setName: IPermissionedStrategySetNameContractFunction

    setPendingManagement: IPermissionedStrategySetPendingManagementContractFunction

    setPerformanceFee: IPermissionedStrategySetPerformanceFeeContractFunction

    setPerformanceFeeRecipient: IPermissionedStrategySetPerformanceFeeRecipientContractFunction

    setProfitMaxUnlockTime: IPermissionedStrategySetProfitMaxUnlockTimeContractFunction

    shutdownStrategy: IPermissionedStrategyShutdownStrategyContractFunction

    shutdownWithdraw: IPermissionedStrategyShutdownWithdrawContractFunction

    symbol: IPermissionedStrategySymbolContractFunction

    tend: IPermissionedStrategyTendContractFunction

    tendThis: IPermissionedStrategyTendThisContractFunction

    tendTrigger: IPermissionedStrategyTendTriggerContractFunction

    tokenizedStrategyAddress: IPermissionedStrategyTokenizedStrategyAddressContractFunction

    totalAssets: IPermissionedStrategyTotalAssetsContractFunction

    totalSupply: IPermissionedStrategyTotalSupplyContractFunction

    transfer: IPermissionedStrategyTransferContractFunction

    transferFrom: IPermissionedStrategyTransferFromContractFunction

    unlockedShares: IPermissionedStrategyUnlockedSharesContractFunction

    withdraw: IPermissionedStrategyWithdrawContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.DOMAIN_SEPARATOR = IPermissionedStrategyDOMAIN_SEPARATORContractFunction.factory(
            "DOMAIN_SEPARATOR",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="DOMAIN_SEPARATOR",
        )
        self.FACTORY = IPermissionedStrategyFACTORYContractFunction.factory(
            "FACTORY",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="FACTORY",
        )
        self.MAX_FEE = IPermissionedStrategyMAX_FEEContractFunction.factory(
            "MAX_FEE",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="MAX_FEE",
        )
        self.acceptManagement = IPermissionedStrategyAcceptManagementContractFunction.factory(
            "acceptManagement",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="acceptManagement",
        )
        self.allowance = IPermissionedStrategyAllowanceContractFunction.factory(
            "allowance",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="allowance",
        )
        self.apiVersion = IPermissionedStrategyApiVersionContractFunction.factory(
            "apiVersion",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="apiVersion",
        )
        self.approve = IPermissionedStrategyApproveContractFunction.factory(
            "approve",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="approve",
        )
        self.asset = IPermissionedStrategyAssetContractFunction.factory(
            "asset",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="asset",
        )
        self.availableDepositLimit = IPermissionedStrategyAvailableDepositLimitContractFunction.factory(
            "availableDepositLimit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="availableDepositLimit",
        )
        self.availableWithdrawLimit = IPermissionedStrategyAvailableWithdrawLimitContractFunction.factory(
            "availableWithdrawLimit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="availableWithdrawLimit",
        )
        self.balanceOf = IPermissionedStrategyBalanceOfContractFunction.factory(
            "balanceOf",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="balanceOf",
        )
        self.convertToAssets = IPermissionedStrategyConvertToAssetsContractFunction.factory(
            "convertToAssets",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="convertToAssets",
        )
        self.convertToShares = IPermissionedStrategyConvertToSharesContractFunction.factory(
            "convertToShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="convertToShares",
        )
        self.decimals = IPermissionedStrategyDecimalsContractFunction.factory(
            "decimals",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="decimals",
        )
        self.deployFunds = IPermissionedStrategyDeployFundsContractFunction.factory(
            "deployFunds",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deployFunds",
        )
        self.deposit = IPermissionedStrategyDepositContractFunction.factory(
            "deposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="deposit",
        )
        self.emergencyAdmin = IPermissionedStrategyEmergencyAdminContractFunction.factory(
            "emergencyAdmin",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="emergencyAdmin",
        )
        self.emergencyWithdraw = IPermissionedStrategyEmergencyWithdrawContractFunction.factory(
            "emergencyWithdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="emergencyWithdraw",
        )
        self.freeFunds = IPermissionedStrategyFreeFundsContractFunction.factory(
            "freeFunds",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="freeFunds",
        )
        self.fullProfitUnlockDate = IPermissionedStrategyFullProfitUnlockDateContractFunction.factory(
            "fullProfitUnlockDate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="fullProfitUnlockDate",
        )
        self.harvestAndReport = IPermissionedStrategyHarvestAndReportContractFunction.factory(
            "harvestAndReport",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="harvestAndReport",
        )
        self.initialize = IPermissionedStrategyInitializeContractFunction.factory(
            "initialize",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="initialize",
        )
        self.isShutdown = IPermissionedStrategyIsShutdownContractFunction.factory(
            "isShutdown",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="isShutdown",
        )
        self.keeper = IPermissionedStrategyKeeperContractFunction.factory(
            "keeper",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="keeper",
        )
        self.lastReport = IPermissionedStrategyLastReportContractFunction.factory(
            "lastReport",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="lastReport",
        )
        self.management = IPermissionedStrategyManagementContractFunction.factory(
            "management",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="management",
        )
        self.maxDeposit = IPermissionedStrategyMaxDepositContractFunction.factory(
            "maxDeposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxDeposit",
        )
        self.maxMint = IPermissionedStrategyMaxMintContractFunction.factory(
            "maxMint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxMint",
        )
        self.maxRedeem = IPermissionedStrategyMaxRedeemContractFunction.factory(
            "maxRedeem",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxRedeem",
        )
        self.maxWithdraw = IPermissionedStrategyMaxWithdrawContractFunction.factory(
            "maxWithdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="maxWithdraw",
        )
        self.mint = IPermissionedStrategyMintContractFunction.factory(
            "mint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="mint",
        )
        self.name = IPermissionedStrategyNameContractFunction.factory(
            "name",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="name",
        )
        self.nonces = IPermissionedStrategyNoncesContractFunction.factory(
            "nonces",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="nonces",
        )
        self.pendingManagement = IPermissionedStrategyPendingManagementContractFunction.factory(
            "pendingManagement",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="pendingManagement",
        )
        self.performanceFee = IPermissionedStrategyPerformanceFeeContractFunction.factory(
            "performanceFee",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="performanceFee",
        )
        self.performanceFeeRecipient = IPermissionedStrategyPerformanceFeeRecipientContractFunction.factory(
            "performanceFeeRecipient",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="performanceFeeRecipient",
        )
        self.permit = IPermissionedStrategyPermitContractFunction.factory(
            "permit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="permit",
        )
        self.previewDeposit = IPermissionedStrategyPreviewDepositContractFunction.factory(
            "previewDeposit",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="previewDeposit",
        )
        self.previewMint = IPermissionedStrategyPreviewMintContractFunction.factory(
            "previewMint",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="previewMint",
        )
        self.previewRedeem = IPermissionedStrategyPreviewRedeemContractFunction.factory(
            "previewRedeem",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="previewRedeem",
        )
        self.previewWithdraw = IPermissionedStrategyPreviewWithdrawContractFunction.factory(
            "previewWithdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="previewWithdraw",
        )
        self.pricePerShare = IPermissionedStrategyPricePerShareContractFunction.factory(
            "pricePerShare",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="pricePerShare",
        )
        self.profitMaxUnlockTime = IPermissionedStrategyProfitMaxUnlockTimeContractFunction.factory(
            "profitMaxUnlockTime",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="profitMaxUnlockTime",
        )
        self.profitUnlockingRate = IPermissionedStrategyProfitUnlockingRateContractFunction.factory(
            "profitUnlockingRate",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="profitUnlockingRate",
        )
        self.redeem = IPermissionedStrategyRedeemContractFunction.factory(
            "redeem",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="redeem",
        )
        self.report = IPermissionedStrategyReportContractFunction.factory(
            "report",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="report",
        )
        self.requireEmergencyAuthorized = IPermissionedStrategyRequireEmergencyAuthorizedContractFunction.factory(
            "requireEmergencyAuthorized",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="requireEmergencyAuthorized",
        )
        self.requireKeeperOrManagement = IPermissionedStrategyRequireKeeperOrManagementContractFunction.factory(
            "requireKeeperOrManagement",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="requireKeeperOrManagement",
        )
        self.requireManagement = IPermissionedStrategyRequireManagementContractFunction.factory(
            "requireManagement",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="requireManagement",
        )
        self.setDepositor = IPermissionedStrategySetDepositorContractFunction.factory(
            "setDepositor",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setDepositor",
        )
        self.setEmergencyAdmin = IPermissionedStrategySetEmergencyAdminContractFunction.factory(
            "setEmergencyAdmin",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setEmergencyAdmin",
        )
        self.setKeeper = IPermissionedStrategySetKeeperContractFunction.factory(
            "setKeeper",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setKeeper",
        )
        self.setName = IPermissionedStrategySetNameContractFunction.factory(
            "setName",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setName",
        )
        self.setPendingManagement = IPermissionedStrategySetPendingManagementContractFunction.factory(
            "setPendingManagement",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setPendingManagement",
        )
        self.setPerformanceFee = IPermissionedStrategySetPerformanceFeeContractFunction.factory(
            "setPerformanceFee",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setPerformanceFee",
        )
        self.setPerformanceFeeRecipient = IPermissionedStrategySetPerformanceFeeRecipientContractFunction.factory(
            "setPerformanceFeeRecipient",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setPerformanceFeeRecipient",
        )
        self.setProfitMaxUnlockTime = IPermissionedStrategySetProfitMaxUnlockTimeContractFunction.factory(
            "setProfitMaxUnlockTime",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="setProfitMaxUnlockTime",
        )
        self.shutdownStrategy = IPermissionedStrategyShutdownStrategyContractFunction.factory(
            "shutdownStrategy",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="shutdownStrategy",
        )
        self.shutdownWithdraw = IPermissionedStrategyShutdownWithdrawContractFunction.factory(
            "shutdownWithdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="shutdownWithdraw",
        )
        self.symbol = IPermissionedStrategySymbolContractFunction.factory(
            "symbol",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="symbol",
        )
        self.tend = IPermissionedStrategyTendContractFunction.factory(
            "tend",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="tend",
        )
        self.tendThis = IPermissionedStrategyTendThisContractFunction.factory(
            "tendThis",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="tendThis",
        )
        self.tendTrigger = IPermissionedStrategyTendTriggerContractFunction.factory(
            "tendTrigger",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="tendTrigger",
        )
        self.tokenizedStrategyAddress = IPermissionedStrategyTokenizedStrategyAddressContractFunction.factory(
            "tokenizedStrategyAddress",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="tokenizedStrategyAddress",
        )
        self.totalAssets = IPermissionedStrategyTotalAssetsContractFunction.factory(
            "totalAssets",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalAssets",
        )
        self.totalSupply = IPermissionedStrategyTotalSupplyContractFunction.factory(
            "totalSupply",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="totalSupply",
        )
        self.transfer = IPermissionedStrategyTransferContractFunction.factory(
            "transfer",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transfer",
        )
        self.transferFrom = IPermissionedStrategyTransferFromContractFunction.factory(
            "transferFrom",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="transferFrom",
        )
        self.unlockedShares = IPermissionedStrategyUnlockedSharesContractFunction.factory(
            "unlockedShares",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="unlockedShares",
        )
        self.withdraw = IPermissionedStrategyWithdrawContractFunction.factory(
            "withdraw",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            abi_element_identifier="withdraw",
        )


class IPermissionedStrategyApprovalContractEvent(ContractEvent):
    """ContractEvent for Approval."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ApprovalEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ApprovalEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ApprovalEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ApprovalEvent.ApprovalEventArgs(
                    owner=abi_event.args["owner"],
                    spender=abi_event.args["spender"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyDepositContractEvent(ContractEvent):
    """ContractEvent for Deposit."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[DepositEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DepositEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DepositEvent.DepositEventArgs(
                    sender=abi_event.args["sender"],
                    owner=abi_event.args["owner"],
                    assets=abi_event.args["assets"],
                    shares=abi_event.args["shares"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[DepositEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            DepositEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=DepositEvent.DepositEventArgs(
                    sender=abi_event.args["sender"],
                    owner=abi_event.args["owner"],
                    assets=abi_event.args["assets"],
                    shares=abi_event.args["shares"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyNewTokenizedStrategyContractEvent(ContractEvent):
    """ContractEvent for NewTokenizedStrategy."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[NewTokenizedStrategyEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            NewTokenizedStrategyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=NewTokenizedStrategyEvent.NewTokenizedStrategyEventArgs(
                    strategy=abi_event.args["strategy"],
                    asset=abi_event.args["asset"],
                    apiVersion=abi_event.args["apiVersion"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[NewTokenizedStrategyEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            NewTokenizedStrategyEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=NewTokenizedStrategyEvent.NewTokenizedStrategyEventArgs(
                    strategy=abi_event.args["strategy"],
                    asset=abi_event.args["asset"],
                    apiVersion=abi_event.args["apiVersion"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyReportedContractEvent(ContractEvent):
    """ContractEvent for Reported."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[ReportedEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReportedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReportedEvent.ReportedEventArgs(
                    profit=abi_event.args["profit"],
                    loss=abi_event.args["loss"],
                    protocolFees=abi_event.args["protocolFees"],
                    performanceFees=abi_event.args["performanceFees"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[ReportedEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            ReportedEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=ReportedEvent.ReportedEventArgs(
                    profit=abi_event.args["profit"],
                    loss=abi_event.args["loss"],
                    protocolFees=abi_event.args["protocolFees"],
                    performanceFees=abi_event.args["performanceFees"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyStrategyShutdownContractEvent(ContractEvent):
    """ContractEvent for StrategyShutdown."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[StrategyShutdownEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            StrategyShutdownEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BaseEventArgs(),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[StrategyShutdownEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            StrategyShutdownEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=BaseEventArgs(),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyTransferContractEvent(ContractEvent):
    """ContractEvent for Transfer."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[TransferEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[TransferEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            TransferEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=TransferEvent.TransferEventArgs(
                    _from=abi_event.args["_from"],
                    to=abi_event.args["to"],
                    value=abi_event.args["value"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdateEmergencyAdminContractEvent(ContractEvent):
    """ContractEvent for UpdateEmergencyAdmin."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdateEmergencyAdminEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateEmergencyAdminEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateEmergencyAdminEvent.UpdateEmergencyAdminEventArgs(
                    newEmergencyAdmin=abi_event.args["newEmergencyAdmin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdateEmergencyAdminEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateEmergencyAdminEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateEmergencyAdminEvent.UpdateEmergencyAdminEventArgs(
                    newEmergencyAdmin=abi_event.args["newEmergencyAdmin"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdateKeeperContractEvent(ContractEvent):
    """ContractEvent for UpdateKeeper."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdateKeeperEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateKeeperEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateKeeperEvent.UpdateKeeperEventArgs(
                    newKeeper=abi_event.args["newKeeper"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdateKeeperEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateKeeperEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateKeeperEvent.UpdateKeeperEventArgs(
                    newKeeper=abi_event.args["newKeeper"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdateManagementContractEvent(ContractEvent):
    """ContractEvent for UpdateManagement."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdateManagementEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateManagementEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateManagementEvent.UpdateManagementEventArgs(
                    newManagement=abi_event.args["newManagement"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdateManagementEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateManagementEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateManagementEvent.UpdateManagementEventArgs(
                    newManagement=abi_event.args["newManagement"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdatePendingManagementContractEvent(ContractEvent):
    """ContractEvent for UpdatePendingManagement."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdatePendingManagementEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdatePendingManagementEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdatePendingManagementEvent.UpdatePendingManagementEventArgs(
                    newPendingManagement=abi_event.args["newPendingManagement"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdatePendingManagementEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdatePendingManagementEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdatePendingManagementEvent.UpdatePendingManagementEventArgs(
                    newPendingManagement=abi_event.args["newPendingManagement"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdatePerformanceFeeContractEvent(ContractEvent):
    """ContractEvent for UpdatePerformanceFee."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdatePerformanceFeeEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdatePerformanceFeeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdatePerformanceFeeEvent.UpdatePerformanceFeeEventArgs(
                    newPerformanceFee=abi_event.args["newPerformanceFee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdatePerformanceFeeEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdatePerformanceFeeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdatePerformanceFeeEvent.UpdatePerformanceFeeEventArgs(
                    newPerformanceFee=abi_event.args["newPerformanceFee"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdatePerformanceFeeRecipientContractEvent(ContractEvent):
    """ContractEvent for UpdatePerformanceFeeRecipient."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdatePerformanceFeeRecipientEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdatePerformanceFeeRecipientEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdatePerformanceFeeRecipientEvent.UpdatePerformanceFeeRecipientEventArgs(
                    newPerformanceFeeRecipient=abi_event.args["newPerformanceFeeRecipient"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdatePerformanceFeeRecipientEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdatePerformanceFeeRecipientEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdatePerformanceFeeRecipientEvent.UpdatePerformanceFeeRecipientEventArgs(
                    newPerformanceFeeRecipient=abi_event.args["newPerformanceFeeRecipient"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyUpdateProfitMaxUnlockTimeContractEvent(ContractEvent):
    """ContractEvent for UpdateProfitMaxUnlockTime."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[UpdateProfitMaxUnlockTimeEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateProfitMaxUnlockTimeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateProfitMaxUnlockTimeEvent.UpdateProfitMaxUnlockTimeEventArgs(
                    newProfitMaxUnlockTime=abi_event.args["newProfitMaxUnlockTime"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[UpdateProfitMaxUnlockTimeEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            UpdateProfitMaxUnlockTimeEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=UpdateProfitMaxUnlockTimeEvent.UpdateProfitMaxUnlockTimeEventArgs(
                    newProfitMaxUnlockTime=abi_event.args["newProfitMaxUnlockTime"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyWithdrawContractEvent(ContractEvent):
    """ContractEvent for Withdraw."""

    # super() get_logs and create_filter methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    # pylint: disable=useless-parent-delegation
    def __init__(self, *argument_names: tuple[str]) -> None:
        super().__init__(*argument_names)

    @combomethod_typed
    def get_logs_typed(
        self,
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier | None = None,
        block_hash: HexBytes | None = None,
    ) -> Iterable[WithdrawEvent]:
        """Extension of `get_logs` that return a typed dataclass of the event."""
        abi_events = super().get_logs(
            argument_filters=argument_filters, from_block=from_block, to_block=to_block, block_hash=block_hash
        )
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    sender=abi_event.args["sender"],
                    receiver=abi_event.args["receiver"],
                    owner=abi_event.args["owner"],
                    assets=abi_event.args["assets"],
                    shares=abi_event.args["shares"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def process_receipt_typed(
        self, txn_receipt: TxReceipt, errors: EventLogErrorFlags = WARN
    ) -> Iterable[WithdrawEvent]:
        """Extension of `process_receipt` that return a typed dataclass of the event."""
        abi_events = super().process_receipt(txn_receipt, errors)
        # TODO there may be issues with this function if the user uses a middleware that changes event structure.
        return [
            WithdrawEvent(
                log_index=abi_event.logIndex,
                transaction_index=abi_event.transactionIndex,
                transaction_hash=abi_event.transactionHash,
                address=abi_event.address,
                block_hash=abi_event.blockHash,
                block_number=abi_event.blockNumber,
                args=WithdrawEvent.WithdrawEventArgs(
                    sender=abi_event.args["sender"],
                    receiver=abi_event.args["receiver"],
                    owner=abi_event.args["owner"],
                    assets=abi_event.args["assets"],
                    shares=abi_event.args["shares"],
                ),
            )
            for abi_event in abi_events
        ]

    @combomethod_typed
    def create_filter(  # type: ignore
        self,
        *,  # PEP 3102
        argument_filters: dict[str, Any] | None = None,
        from_block: BlockIdentifier | None = None,
        to_block: BlockIdentifier = "latest",
        address: ChecksumAddress | None = None,
        topics: Sequence[Any] | None = None,
    ) -> LogFilter:
        return cast(
            LogFilter,
            super().create_filter(
                argument_filters=argument_filters,
                from_block=from_block,
                to_block=to_block,
                address=address,
                topics=topics,
            ),
        )


class IPermissionedStrategyContractEvents(ContractEvents):
    """ContractEvents for the IPermissionedStrategy contract."""

    Approval: IPermissionedStrategyApprovalContractEvent

    Deposit: IPermissionedStrategyDepositContractEvent

    NewTokenizedStrategy: IPermissionedStrategyNewTokenizedStrategyContractEvent

    Reported: IPermissionedStrategyReportedContractEvent

    StrategyShutdown: IPermissionedStrategyStrategyShutdownContractEvent

    Transfer: IPermissionedStrategyTransferContractEvent

    UpdateEmergencyAdmin: IPermissionedStrategyUpdateEmergencyAdminContractEvent

    UpdateKeeper: IPermissionedStrategyUpdateKeeperContractEvent

    UpdateManagement: IPermissionedStrategyUpdateManagementContractEvent

    UpdatePendingManagement: IPermissionedStrategyUpdatePendingManagementContractEvent

    UpdatePerformanceFee: IPermissionedStrategyUpdatePerformanceFeeContractEvent

    UpdatePerformanceFeeRecipient: IPermissionedStrategyUpdatePerformanceFeeRecipientContractEvent

    UpdateProfitMaxUnlockTime: IPermissionedStrategyUpdateProfitMaxUnlockTimeContractEvent

    Withdraw: IPermissionedStrategyWithdrawContractEvent

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
    ) -> None:
        super().__init__(abi, w3, address)
        self.Approval = IPermissionedStrategyApprovalContractEvent.factory(
            "Approval", w3=w3, contract_abi=abi, address=address, event_name="Approval"
        )
        self.Deposit = IPermissionedStrategyDepositContractEvent.factory(
            "Deposit", w3=w3, contract_abi=abi, address=address, event_name="Deposit"
        )
        self.NewTokenizedStrategy = IPermissionedStrategyNewTokenizedStrategyContractEvent.factory(
            "NewTokenizedStrategy", w3=w3, contract_abi=abi, address=address, event_name="NewTokenizedStrategy"
        )
        self.Reported = IPermissionedStrategyReportedContractEvent.factory(
            "Reported", w3=w3, contract_abi=abi, address=address, event_name="Reported"
        )
        self.StrategyShutdown = IPermissionedStrategyStrategyShutdownContractEvent.factory(
            "StrategyShutdown", w3=w3, contract_abi=abi, address=address, event_name="StrategyShutdown"
        )
        self.Transfer = IPermissionedStrategyTransferContractEvent.factory(
            "Transfer", w3=w3, contract_abi=abi, address=address, event_name="Transfer"
        )
        self.UpdateEmergencyAdmin = IPermissionedStrategyUpdateEmergencyAdminContractEvent.factory(
            "UpdateEmergencyAdmin", w3=w3, contract_abi=abi, address=address, event_name="UpdateEmergencyAdmin"
        )
        self.UpdateKeeper = IPermissionedStrategyUpdateKeeperContractEvent.factory(
            "UpdateKeeper", w3=w3, contract_abi=abi, address=address, event_name="UpdateKeeper"
        )
        self.UpdateManagement = IPermissionedStrategyUpdateManagementContractEvent.factory(
            "UpdateManagement", w3=w3, contract_abi=abi, address=address, event_name="UpdateManagement"
        )
        self.UpdatePendingManagement = IPermissionedStrategyUpdatePendingManagementContractEvent.factory(
            "UpdatePendingManagement", w3=w3, contract_abi=abi, address=address, event_name="UpdatePendingManagement"
        )
        self.UpdatePerformanceFee = IPermissionedStrategyUpdatePerformanceFeeContractEvent.factory(
            "UpdatePerformanceFee", w3=w3, contract_abi=abi, address=address, event_name="UpdatePerformanceFee"
        )
        self.UpdatePerformanceFeeRecipient = IPermissionedStrategyUpdatePerformanceFeeRecipientContractEvent.factory(
            "UpdatePerformanceFeeRecipient",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="UpdatePerformanceFeeRecipient",
        )
        self.UpdateProfitMaxUnlockTime = IPermissionedStrategyUpdateProfitMaxUnlockTimeContractEvent.factory(
            "UpdateProfitMaxUnlockTime",
            w3=w3,
            contract_abi=abi,
            address=address,
            event_name="UpdateProfitMaxUnlockTime",
        )
        self.Withdraw = IPermissionedStrategyWithdrawContractEvent.factory(
            "Withdraw", w3=w3, contract_abi=abi, address=address, event_name="Withdraw"
        )


class IPermissionedStrategyContract(Contract):
    """A web3.py Contract class for the IPermissionedStrategy contract."""

    abi: ABI = ipermissionedstrategy_abi
    # We change `bytecode` as needed for linking, but keep
    # `_raw_bytecode` unchanged as an original copy.
    # pylint: disable=line-too-long
    _raw_bytecode: HexStr | None = HexStr("0x")

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        # Initialize parent Contract class
        super().__init__(address=address)
        self.functions = IPermissionedStrategyContractFunctions(ipermissionedstrategy_abi, self.w3, address)  # type: ignore
        self.events = IPermissionedStrategyContractEvents(ipermissionedstrategy_abi, self.w3, address)  # type: ignore

    events: IPermissionedStrategyContractEvents

    functions: IPermissionedStrategyContractFunctions

    @classmethod
    def constructor(cls) -> ContractConstructor:  # type: ignore
        """Creates a transaction with the contract's constructor function.

        Parameters
        ----------

        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.

        """
        cls.bytecode = cls._raw_bytecode
        if cls.bytecode is not None:

            # bytecode needs to be in hex for web3
            cls.bytecode = HexBytes(cls.bytecode)

        return super().constructor()

    @classmethod
    def deploy(cls, w3: Web3, account: LocalAccount | ChecksumAddress) -> Self:
        """Deploys an instance of the contract.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        account : LocalAccount
            The account to use to deploy the contract.

        Returns
        -------
        Self
            A deployed instance of the contract.
        """
        deployer = cls.factory(w3=w3)
        constructor_fn = deployer.constructor()

        # if an address is supplied, try to use a web3 default account
        if isinstance(account, str):
            tx_hash = constructor_fn.transact({"from": account})
            tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

            deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
            return deployed_contract

        # otherwise use the account provided.
        deployment_tx = constructor_fn.build_transaction()
        current_nonce = w3.eth.get_transaction_count(account.address, "pending")
        deployment_tx.update({"nonce": current_nonce})

        # Sign the transaction with local account private key
        signed_tx = account.sign_transaction(deployment_tx)

        # Send the signed transaction and wait for receipt
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

        deployed_contract = deployer(address=tx_receipt.contractAddress)  # type: ignore
        return deployed_contract

    @classmethod
    def factory(cls, w3: Web3, class_name: str | None = None, **kwargs: Any) -> Type[Self]:
        """Initializes the contract object.

        Parameters
        ----------
        w3 : Web3
            A web3 instance.
        class_name: str | None
            The instance class name.

        Returns
        -------
        Self
            An instance of the contract class.
        """
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = IPermissionedStrategyContractFunctions(ipermissionedstrategy_abi, w3, None)

        return contract
